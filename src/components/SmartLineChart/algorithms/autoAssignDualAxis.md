# 自动双轴判断与左右 Y 轴推荐算法（autoAssignDualAxis）技术文档

## 一、算法概述

### 1.1 背景与目标

在数据可视化场景中，当图表包含多个 Y 轴指标时，开发面临以下问题：

- **量纲差异**：不同指标的数值范围可能相差数个数量级（如销售额 vs 转化率）
- **视觉失真**：将差异悬殊的指标放在同一坐标轴，会导致小数值指标"被压扁"
- **手动配置成本高**：需要开发者判断是否启用双轴，以及如何分配左右轴

`autoAssignDualAxis` 算法的目标是：**自动判断是否需要双轴图，并智能分配左右 Y 轴的数据系列**，实现"零配置"的最优展示效果。

### 1.2 核心决策逻辑

算法采用 **两步决策框架**：

| 步骤   | 决策内容       | 核心思想                               |
| ------ | -------------- | -------------------------------------- |
| Step 1 | 双轴必要性判断 | 基于数值类型和量级差异判断是否需要双轴 |
| Step 2 | 左右轴分配     | 使用 K-Means++ 聚类算法智能分组        |

### 1.3 决策流程概览

```
输入Y轴数据 → 统计分析 → [双轴判断] → 需要双轴? → [K-Means++聚类] → 输出左右轴分配
                                    ↓ 不需要
                              输出单轴配置
```

---

## 二、算法配置参数

| 参数名    | 默认值 | 说明                       |
| --------- | ------ | -------------------------- |
| `MAX_GAP` | 10     | 双轴判断的最大差距倍数阈值 |

---

## 三、核心技术实现（两步决策详解）

### Step 1：双轴必要性判断

**目标**：判断多个 Y 轴指标是否需要使用双轴图展示。

#### 1.1 前置条件检查

```typescript
// 指标数量 < 2：不需要双轴
if (keys.length < 2) return false;

// 指标值不是数字：不需要双轴
const allNumber = keys.every((k) => metrics[k].values.every((v) => typeof v === 'number'));
if (!allNumber) return false;
```

#### 1.2 数值类型判断

算法将指标分为两种类型：

| 类型       | 判断条件          | 典型场景             |
| ---------- | ----------------- | -------------------- |
| `ratio`    | -1 ≤ 值 ≤ 1       | 转化率、占比、增长率 |
| `absolute` | 值 < -1 或 值 > 1 | 销售额、用户数、金额 |

```typescript
const types = keys.map((name) => {
  const { min, max } = metrics[name].stats;
  return min >= -1 && max <= 1 ? 'ratio' : 'absolute';
});

// 同时存在比例值和绝对值 → 需要双轴
const hasRatio = types.includes('ratio');
const hasAbs = types.includes('absolute');
if (hasRatio && hasAbs) return true;
```

**设计理念**：比例值（如 0.85）和绝对值（如 10000）放在同一坐标轴会导致比例值几乎不可见。

#### 1.3 量级差异判断

当所有指标都是同一类型时，通过最大值差距判断：

```typescript
const maxVals = keys.map((k) => metrics[k].stats.max);
const maxVal = Math.max(...maxVals);
const minVal = Math.min(...maxVals);

// 除零保护
if (minVal <= 0) {
  return Math.abs(maxVal - minVal) > Math.abs(minVal) * MAX_GAP;
}

// 差距超过 10 倍 → 需要双轴
const gap = maxVal / minVal;
return gap > MAX_GAP;
```

**判断规则总结**：

| 条件                 | 结果     | 说明             |
| -------------------- | -------- | ---------------- |
| 指标数量 < 2         | 单轴     | 无需分轴         |
| 存在非数字值         | 单轴     | 无法计算统计量   |
| 同时有比例值和绝对值 | **双轴** | 类型混合必须分轴 |
| 最大值差距 > 10 倍   | **双轴** | 量级差异过大     |
| 其他情况             | 单轴     | 可共用坐标轴     |

---

### Step 2：左右轴分配（K-Means++ 聚类）

**目标**：将多个指标智能分配到左右两个坐标轴。

**算法选择**：使用 **K-Means++ 聚类算法**，将相似的指标分到同一组。

#### 2.1 特征向量构建

为每个指标构建三维特征向量：

```typescript
Object.keys(metrics).forEach((k) => {
  const { min, max, median } = metrics[k].stats;
  vectors[k] = [min, max, median]; // 三维特征向量
});
```

| 特征维度 | 含义   | 作用             |
| -------- | ------ | ---------------- |
| `min`    | 最小值 | 反映数据下界     |
| `max`    | 最大值 | 反映数据上界     |
| `median` | 中位数 | 反映数据集中趋势 |

**设计理念**：使用三个统计量而非原始数据，既降低维度又保留关键分布特征。

#### 2.2 K-Means++ 聚类

调用 K-Means++ 算法将指标分为 2 组（k=2）：

```typescript
const [left, right] = kMeansPlusPlus(vectors, 2).sort(
  (a, b) => medianOfGroup(b) - medianOfGroup(a),
);
```

**K-Means++ 优势**：

- 智能初始化质心，避免传统 K-Means 的随机性问题
- 收敛更快，结果更稳定

#### 2.3 左右轴排序规则

按组的中位数均值降序排列：

```typescript
function medianOfGroup(g: string[]): number {
  return g.reduce((s, key) => s + metrics[key].stats.median, 0) / g.length;
}

// 中位数大的分配到左轴（主轴）
.sort((a, b) => medianOfGroup(b) - medianOfGroup(a))
```

**排序规则**：

| 位置 | 分配规则       | 说明                 |
| ---- | -------------- | -------------------- |
| 左轴 | 中位数较大的组 | 作为主轴，视觉更突出 |
| 右轴 | 中位数较小的组 | 作为副轴，辅助展示   |

---

## 四、统计工具函数

### getStats：计算统计量

```typescript
function getStats(arr: number[]): Stats {
  if (!arr || arr.length === 0) {
    return { min: 0, max: 0, median: 0 };
  }

  const sorted = [...arr].sort((a, b) => a - b);

  return {
    min: sorted[0],
    max: sorted[sorted.length - 1],
    median: sorted[Math.floor(sorted.length / 2)],
  };
}
```

| 返回值   | 计算方式           | 用途                |
| -------- | ------------------ | ------------------- |
| `min`    | 排序后第一个元素   | 数值类型判断        |
| `max`    | 排序后最后一个元素 | 量级差异计算        |
| `median` | 排序后中间位置元素 | 聚类特征 + 排序依据 |

---

## 五、完整决策流程图

```
                    ┌─────────────────┐
                    │  输入 Y 轴数据   │
                    │  (keys + data)  │
                    └────────┬────────┘
                             │
               ┌─────────────▼─────────────┐
               │      构造指标统计         │
               │  计算 min/max/median      │
               └─────────────┬─────────────┘
                             │
               ┌─────────────▼─────────────┐
               │  Step 1: 双轴必要性判断   │
               └─────────────┬─────────────┘
                             │
              ┌──────────────┼──────────────┐
              │              │              │
              ▼              ▼              ▼
      ┌────────────┐ ┌────────────┐ ┌────────────┐
      │ 指标 < 2?  │ │比例+绝对值?│ │差距 > 10倍?│
      │   → 单轴   │ │  → 双轴   │ │  → 双轴   │
      └────────────┘ └────────────┘ └────────────┘
                             │
                    需要双轴？│
                             │
              ┌──────────────┴──────────────┐
              │ 否                          │ 是
              ▼                             ▼
      ┌────────────┐              ┌─────────────────┐
      │ 返回单轴   │              │ Step 2: 聚类分配│
      │ isDual:false│             │ K-Means++ (k=2) │
      └────────────┘              └────────┬────────┘
                                           │
                                  ┌────────▼────────┐
                                  │  按中位数排序   │
                                  │  分配左右轴     │
                                  └────────┬────────┘
                                           │
                                  ┌────────▼────────┐
                                  │  返回双轴配置   │
                                  │ isDual: true    │
                                  │ left: [...],    │
                                  │ right: [...]    │
                                  └─────────────────┘
```

---

## 六、输出数据结构

### 6.1 返回类型定义

```typescript
interface SmartLineChartConfig {
  isDual: boolean; // 是否启用双轴
  category?: {
    left: string[]; // 左轴指标列表
    right: string[]; // 右轴指标列表
  };
}
```

### 6.2 返回示例

**单轴场景**：

```typescript
{
  isDual: false;
}
```

**双轴场景**：

```typescript
{
  isDual: true,
  category: {
    left: ["销售额", "订单量"],      // 大数值指标
    right: ["转化率", "复购率"]      // 比例指标
  }
}
```

---

## 七、算法优势与特点

### 7.1 技术优势

| 优势         | 说明                               |
| ------------ | ---------------------------------- |
| **智能判断** | 自动识别是否需要双轴，无需人工配置 |
| **类型感知** | 区分比例值和绝对值，避免量纲混淆   |
| **聚类分组** | K-Means++ 确保相似指标分到同一轴   |
| **稳定排序** | 按中位数排序，保证结果一致性       |
| **边界保护** | 完善的空值和除零处理               |

### 7.2 设计亮点

1. **两层判断**：先判断类型（比例/绝对），再判断量级差异
2. **特征降维**：用 min/max/median 三维向量代替原始数据
3. **智能排序**：大数值放左轴（主轴），符合用户阅读习惯
4. **算法复用**：调用通用的 K-Means++ 聚类库

---

## 八、应用场景示例

| 场景            | 输入指标              | 输出结果                     |
| --------------- | --------------------- | ---------------------------- |
| 销售 + 转化率   | 销售额(万), 转化率(%) | 双轴：左[销售额], 右[转化率] |
| 多个金额指标    | 销售额, 成本, 利润    | 单轴（量级相近）             |
| 用户数 + 增长率 | DAU(万), 增长率(%)    | 双轴：左[DAU], 右[增长率]    |
| 大小数值混合    | 总收入(亿), 笔均(元)  | 双轴：左[总收入], 右[笔均]   |

**示例详解**：

```
输入：
  yAxisKeys: ["销售额", "转化率", "客单价"]
  yAxisData: {
    "销售额": [10000, 12000, 15000, 18000],
    "转化率": [0.05, 0.06, 0.07, 0.08],
    "客单价": [200, 220, 250, 280]
  }

分析：
  销售额: max=18000, type=absolute
  转化率: max=0.08, type=ratio      ← 比例值
  客单价: max=280, type=absolute

判断：存在比例值 + 绝对值 → 需要双轴

聚类：
  K-Means++ 将 [销售额, 客单价] 和 [转化率] 分为两组

输出：
  {
    isDual: true,
    category: {
      left: ["销售额", "客单价"],   // 绝对值组（中位数大）
      right: ["转化率"]             // 比例值组
    }
  }
```

---

## 九、函数接口说明

### 主函数

```typescript
function autoAssignDualAxis(
  yAxisKeys: string[],
  yAxisData: Record<string, number[]>,
): SmartLineChartConfig;
```

| 参数       | 类型                     | 说明             |
| ---------- | ------------------------ | ---------------- |
| yAxisKeys  | string[]                 | Y 轴指标名称列表 |
| yAxisData  | Record<string, number[]> | 各指标的数据数组 |
| **返回值** | SmartLineChartConfig     | 双轴配置结果     |

### 内部函数

| 函数名                | 功能                      |
| --------------------- | ------------------------- |
| `getStats()`          | 计算数组的 min/max/median |
| `shouldUseDualAxis()` | 判断是否需要双轴          |
| `assignLeftRight()`   | K-Means++ 聚类分配左右轴  |

### 依赖函数

| 函数名             | 来源                         | 功能               |
| ------------------ | ---------------------------- | ------------------ |
| `kMeansPlusPlus()` | `@/components/algorithmsLab` | K-Means++ 聚类算法 |

---

## 十、总结

`autoAssignDualAxis` 算法通过 **两步智能决策**，实现了双轴图的自动配置：

| 步骤   | 核心能力   | 技术手段                    |
| ------ | ---------- | --------------------------- |
| Step 1 | 双轴判断   | 类型识别 + 量级差异分析     |
| Step 2 | 左右轴分配 | K-Means++ 聚类 + 中位数排序 |

**核心价值**：

1. **降低配置成本**：自动判断 + 自动分组，实现零配置
2. **提升展示效果**：避免量纲差异导致的视觉失真
3. **增强智能化体验**：体现"数据驱动"的产品理念

---

**文档版本**：v1.0  
**最后更新**：2026 年 1 月 16 日
