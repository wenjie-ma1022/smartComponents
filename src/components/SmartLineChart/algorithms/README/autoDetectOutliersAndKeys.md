# 异常值/关键值自动检测与高亮算法（autoDetectOutliersAndKeys）技术文档

## 一、算法概述

### 1.1 背景与目标

在数据可视化场景中，图表往往包含大量数据点，开发面临以下问题：

- 难以快速定位数据中的异常值（如极端偏离的数据点）
- 难以识别关键业务节点（如最大值、最小值、突变点）
- 手动标注成本高，且容易遗漏

`autoDetectOutliersAndKeys` 算法的目标是：**基于统计学方法自动检测并高亮数据中的异常值与关键点**，帮助用户快速洞察数据特征。

### 1.2 核心检测能力

算法提供 **四种检测能力**：

| 检测类型       | 标记类型         | 核心思想                            |
| -------------- | ---------------- | ----------------------------------- |
| IQR 离群值检测 | `outlier`        | 基于四分位距识别统计异常点          |
| 趋势偏离检测   | `trendDeviation` | 基于线性回归残差识别偏离趋势的点    |
| 全局极值检测   | `keyPoint`       | 识别全局最大值和最小值              |
| 突变检测       | `keyPoint`       | 基于一阶差分识别数据突增/突降的拐点 |

### 1.3 检测流程概览

```
输入数据 → 数据清洗 → [离群值检测] → [趋势偏离检测] → [突变检测] → [极值检测] → 去重合并 → 输出高亮点
```

---

## 二、算法配置参数

### 2.1 功能开关

| 参数名                | 类型    | 说明                             |
| --------------------- | ------- | -------------------------------- |
| `checkOutliers`       | boolean | 是否开启 IQR 离群值检测          |
| `checkTrendDeviation` | boolean | 是否开启趋势偏离检测（仅折线图） |
| `checkMaxMin`         | boolean | 是否开启全局极值检测             |
| `checkSharpChange`    | boolean | 是否开启突变检测                 |

### 2.2 阈值参数

| 参数名                     | 默认值 | 说明                                 |
| -------------------------- | ------ | ------------------------------------ |
| `iqrMultiplier`            | 1.5    | IQR 倍数，用于确定离群值边界         |
| `trendSigma`               | 2.5    | 趋势残差的 Z-Score 阈值              |
| `sharpChangeSigma`         | 3.0    | 突变检测的 Z-Score 阈值              |
| `minSamplesForIqr`         | 5      | IQR 检测的最小样本数                 |
| `minSamplesForTrend`       | 6      | 趋势检测的最小样本数                 |
| `minSamplesForSharpChange` | 3      | 突变检测的最小样本数                 |
| `minR2ForTrend`            | 0.4    | 趋势检测的 R² 阈值，低于此值跳过检测 |
| `debug`                    | false  | 是否打印调试日志                     |

---

## 三、核心技术实现（四种检测详解）

### 检测一：IQR 离群值检测

**目标**：识别数据中统计意义上的异常点（极端偏高或偏低的值）。

**算法原理**：基于 **四分位距法（IQR）**，这是箱线图的核心逻辑。

#### 计算步骤

**Step 1：计算四分位数**

```typescript
const sorted = [...values].sort((a, b) => a - b);
const q1 = quantile(sorted, 0.25); // 25% 分位数
const q3 = quantile(sorted, 0.75); // 75% 分位数
const iqr = q3 - q1; // 四分位距
```

**Step 2：确定有效范围**

```typescript
// 经典 1.5 倍 IQR 规则
const lower = q1 - 1.5 * iqr; // 下界
const upper = q3 + 1.5 * iqr; // 上界
```

**Step 3：标记离群点**

```typescript
if (value < lower) → 标记为「数值异常偏低」
if (value > upper) → 标记为「数值异常偏高」
```

**图示说明**：

```
                    ┌─────────────────┐
    异常偏低        │   正常数据范围   │        异常偏高
◄──────────────────►│◄───────────────►│◄──────────────────►
                    └─────────────────┘
        lower       Q1              Q3       upper
      (Q1-1.5*IQR)                         (Q3+1.5*IQR)
```

**边界处理**：

- 样本数 < 5：跳过检测（样本太少统计无意义）
- IQR = 0：跳过检测（数据完全一致）

---

### 检测二：趋势偏离检测

**目标**：识别明显偏离整体趋势的数据点（仅对折线图有效）。

**算法原理**：基于 **线性回归残差分析**，使用 Z-Score 判定异常。

#### 计算步骤

**Step 1：线性回归拟合**

对数据进行简单线性回归，得到趋势线：

```typescript
const { slope, intercept, r2 } = linearRegression(values);
// 趋势线：y = slope * x + intercept
```

**Step 2：R² 门槛判断**

```typescript
// 如果数据本身不具备线性趋势，跳过检测
if (r2 < 0.4) {
  return []; // R² 太低，趋势检测无意义
}
```

| R² 范围  | 含义                 | 处理方式     |
| -------- | -------------------- | ------------ |
| R² < 0.4 | 数据无明显线性趋势   | 跳过趋势检测 |
| R² ≥ 0.4 | 数据具有一定线性趋势 | 继续检测     |

**Step 3：计算残差**

```typescript
// 残差 = 实际值 - 预测值
const residuals = values.map((v, i) => v - (slope * i + intercept));
```

**Step 4：Z-Score 异常判定**

```typescript
const mu = mean(residuals);     // 残差均值
const sigma = std(residuals);   // 残差标准差

// Z-Score > 2.5 倍标准差 → 标记为趋势偏离
if (Math.abs(residual - mu) > 2.5 * sigma) {
  → 标记为「明显偏离整体趋势」
}
```

**图示说明**：

```
    值
    │      •  ← 趋势偏离点（残差过大）
    │    /
    │  / •
    │/•
    •─────────────────── 趋势线
    │
    └──────────────────── 索引
```

---

### 检测三：全局极值检测

**目标**：识别数据中的最大值和最小值，作为关键业务节点。

**算法原理**：遍历数据找到全局极值，支持并列极值。

#### 计算步骤

```typescript
// Step 1: 找到极值
let min = values[0], max = values[0];
for (const v of values) {
  if (v < min) min = v;
  if (v > max) max = v;
}

// Step 2: 标记所有极值点（支持并列）
values.forEach((v, i) => {
  if (v === max) → 标记为「全局最大值」
  if (v === min) → 标记为「全局最小值」
});
```

**特殊处理**：

- 最大值 = 最小值（恒定数据）：只标记第一个点，避免全屏高亮

---

### 检测四：突变检测（突增/突降）

**目标**：识别数据中的拐点，即相邻数据点之间发生剧烈变化的位置。

**算法原理**：基于 **一阶差分 + Z-Score** 检测突变。

#### 计算步骤

**Step 1：计算一阶差分**

```typescript
// diff[i] = values[i+1] - values[i]
const diffs: number[] = [];
for (let i = 1; i < values.length; i++) {
  diffs.push(values[i] - values[i - 1]);
}
```

**Step 2：Z-Score 异常判定**

```typescript
const mu = mean(diffs);    // 差分均值
const sigma = std(diffs);  // 差分标准差

// Z-Score > 3.0 倍标准差 → 标记为突变
if (Math.abs(diff - mu) > 3.0 * sigma) {
  if (diff > 0) → 标记为「数据突增」
  if (diff < 0) → 标记为「数据突降」
}
```

**图示说明**：

```
    值
    │           •  ← 突增点
    │          /│
    │         / │
    │    •···•  │
    │   /       •···•  ← 突降点
    │  /              \
    │ •                •
    └──────────────────── 索引
```

---

## 四、优先级与去重机制

### 4.1 类型优先级

同一个数据点可能被多种检测算法标记，采用 **优先级机制** 去重：

| 类型             | 优先级    | 说明                    |
| ---------------- | --------- | ----------------------- |
| `outlier`        | 3（最高） | 离群值优先级最高        |
| `trendDeviation` | 2         | 趋势偏离次之            |
| `keyPoint`       | 1（最低） | 关键点（极值/突变）最低 |

### 4.2 去重逻辑

```typescript
const addPoint = (point: HighlightPoint) => {
  const existing = resultMap.get(point.index);
  // 新标记优先级更高时才更新
  if (!existing || priority[point.type] > priority[existing.type]) {
    resultMap.set(point.index, point);
  }
};
```

**示例**：某点同时被标记为「离群值」和「全局最大值」，最终只保留「离群值」标记。

---

## 五、完整检测流程图

```
                    ┌─────────────────┐
                    │   输入 Y 轴数据  │
                    └────────┬────────┘
                             │
               ┌─────────────▼─────────────┐
               │      数据清洗             │
               │  过滤 NaN/Infinity 等无效值│
               └─────────────┬─────────────┘
                             │
         ┌───────────────────┼───────────────────┐
         │                   │                   │
         ▼                   ▼                   ▼
┌────────────────┐  ┌────────────────┐  ┌────────────────┐
│ checkOutliers? │  │checkTrendDev?  │  │checkSharpChange│
│                │  │ (仅折线图)      │  │                │
│  IQR 离群值    │  │  趋势偏离      │  │  突变检测      │
│  检测          │  │  检测          │  │                │
└───────┬────────┘  └───────┬────────┘  └───────┬────────┘
        │                   │                   │
        └───────────────────┼───────────────────┘
                            │
               ┌────────────▼────────────┐
               │    checkMaxMin?         │
               │    全局极值检测          │
               └────────────┬────────────┘
                            │
               ┌────────────▼────────────┐
               │   优先级去重 & 合并      │
               └────────────┬────────────┘
                            │
                   ┌────────▼────────┐
                   │  输出高亮点列表  │
                   │  (按索引排序)    │
                   └─────────────────┘
```

---

## 六、输出数据结构

### 6.1 高亮点类型定义

```typescript
interface HighlightPoint {
  index: number; // 数据点索引
  value: number; // 数据值
  type: "outlier" | "trendDeviation" | "keyPoint"; // 标记类型
  reason: string; // 标记原因（用于 tooltip 展示）
}
```

### 6.2 reason 枚举

| type             | reason 可能值                                                    |
| ---------------- | ---------------------------------------------------------------- |
| `outlier`        | "数值异常偏低"、"数值异常偏高"                                   |
| `trendDeviation` | "明显偏离整体趋势"                                               |
| `keyPoint`       | "全局最大值"、"全局最小值"、"数据突增"、"数据突降"、"全量恒定值" |

---

## 七、算法优势与特点

### 7.1 技术优势

| 优势           | 说明                                      |
| -------------- | ----------------------------------------- |
| **多维检测**   | 四种检测算法覆盖不同类型的异常和关键点    |
| **统计严谨**   | 基于 IQR、Z-Score、线性回归等经典统计方法 |
| **智能门槛**   | R² 门槛避免无意义的趋势检测               |
| **优先级机制** | 同一点多种标记时保留最重要的              |
| **参数可调**   | 所有阈值可配置，适应不同业务场景          |

### 7.2 设计亮点

1. **数据清洗**：自动过滤无效值，保持索引映射正确
2. **R² 门槛**：趋势检测前判断数据是否具备线性特征，避免误报
3. **并列极值**：支持多个最大/最小值同时标记
4. **图表类型感知**：趋势偏离检测仅对折线图生效

---

## 八、应用场景示例

| 场景           | 推荐开启的检测             | 说明                       |
| -------------- | -------------------------- | -------------------------- |
| 销售额月度趋势 | 离群值 + 趋势偏离 + 极值   | 识别异常月份和峰值         |
| 服务器监控指标 | 离群值 + 突变检测          | 快速发现性能异常和突发问题 |
| 股票价格走势   | 趋势偏离 + 突变检测 + 极值 | 识别拐点和极端行情         |
| 用户增长数据   | 极值 + 突变检测            | 标记增长里程碑和爆发点     |

---

## 九、函数接口说明

### 主函数

```typescript
function autoDetectOutliersAndKeys(
  values: number[],
  chartType: SmartLineSeriesType,
  detectConfig?: AutoDetectConfig & Partial<DetectionOptions>
): HighlightPoint[];
```

| 参数         | 类型             | 说明                     |
| ------------ | ---------------- | ------------------------ |
| values       | number[]         | Y 轴数据数组             |
| chartType    | "bar" \| "line"  | 图表类型                 |
| detectConfig | AutoDetectConfig | 检测配置（开关 + 阈值）  |
| **返回值**   | HighlightPoint[] | 高亮点列表（按索引排序） |

### 内部检测函数

| 函数名                   | 功能           | 返回类型         |
| ------------------------ | -------------- | ---------------- |
| `detectIqrOutliers()`    | IQR 离群值检测 | HighlightPoint[] |
| `detectTrendDeviation()` | 趋势偏离检测   | HighlightPoint[] |
| `detectGlobalExtrema()`  | 全局极值检测   | HighlightPoint[] |
| `detectSharpChange()`    | 突变检测       | HighlightPoint[] |

### 基础统计函数

| 函数名               | 功能                   |
| -------------------- | ---------------------- |
| `mean()`             | 计算均值               |
| `std()`              | 计算样本标准差         |
| `quantile()`         | 计算分位数（线性插值） |
| `linearRegression()` | 线性回归（含 R²）      |

---

## 十、总结

`autoDetectOutliersAndKeys` 算法通过 **四种检测机制**，实现了数据异常值与关键点的自动识别：

| 检测类型     | 技术手段           | 标记类型         |
| ------------ | ------------------ | ---------------- |
| 离群值检测   | IQR 四分位距法     | `outlier`        |
| 趋势偏离检测 | 线性回归残差分析   | `trendDeviation` |
| 极值检测     | 全局最大/最小值    | `keyPoint`       |
| 突变检测     | 一阶差分 + Z-Score | `keyPoint`       |

**核心价值**：

1. **提升数据洞察效率**：自动标记关键信息，无需人工逐点排查
2. **降低遗漏风险**：统计方法确保异常点不被忽略
3. **增强图表表达力**：高亮点让数据故事更加清晰

---

**文档版本**：v1.0  
**最后更新**：2026 年 1 月 16 日
